<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习预备知识</title>
    <link href="/2024/07/28/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/07/28/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习的是李沐的《动手学深度学习》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[动手学深度学习](https://zh.d2l.ai/index.html)">[2]</span></a></sup></p><h1 id="深度学习框架">深度学习框架</h1><p>先主要了解三个深度学习框架，MXNET、PYTORCH、TENSORFLOW。</p><h2>MXNET</h2><p>MXNet是开源深度学习框架，允许用户在多种设备（无论是云基础设施还是移动设备）上定义、训练和部署深度神经网络。该框架具备高度可扩展性，可以进行快速的模型训练，并支持灵活的编程模型和多种语言。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[什么是 Apache MXNet？](https://www.nvidia.cn/glossary/data-science/mxnet/)">[1]</span></a></sup>。它于2015年由亚马逊团队开发。这里就介绍命令行安装方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install mxnet   <br><span class="hljs-comment">#GPU版本的MXNet:</span><br>pip install mxnet-cu111<br></code></pre></td></tr></table></figure><p>导包不出错则证明安装成功。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入np和npx模块，np模块包含了numpy支持的函数，而npx模块则包含了一些扩展函数</span><br><span class="hljs-keyword">from</span> mxnet <span class="hljs-keyword">import</span> np,npx<br><span class="hljs-comment">#在使用张量之前基本上都会调用下面这个函数，目的是为了兼容mxnet的其他张量处理</span><br>npx.set_np()<br><br></code></pre></td></tr></table></figure></p><h2>PYTORCH</h2><p>PyTorch是一个由Facebook的人工智能研究团队开发的开源深度学习框架PyTorch最突出的优点之一就是它使用了动态计算图（Dynamic ComputationGraphs，DCGs），提供了大量的预训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install torch   <br></code></pre></td></tr></table></figure><p>安装完成后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#直接导入</span><br><span class="hljs-keyword">import</span> torch <br></code></pre></td></tr></table></figure><h2>TENSORFLOW</h2><p>TensorFlow是由GoogleBrain团队开发的开源机器学习框架，致力于数据流图的自动微分和深度神经网络计算。它跨平台且灵活，广泛用于构建、训练和部署机器学习模型.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install tensorflow   <br></code></pre></td></tr></table></figure><p>安装完成后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#直接导入</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf <br></code></pre></td></tr></table></figure><h2 id="基本使用">基本使用</h2><h4>什么是张量</h4><p>张量就是一些数值组成的数组，比如说0维张量就是指一个数，数组中只保存了一个数字，又称为标量，可以用ndim属性来查看一个数组的轴的个数，对于轴数的一个简单判断方法就是看第一个数字前面有几个[]括号，所以在标量中只有一个数因此标量中的ndim==0，1维张量就是我们所熟知的向量，2维张量俗称矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#张量的构造方法,以下构造了一个0-11的十二位一维张量。</span><br><span class="hljs-comment">#MXNET</span><br>x = np.arange(<span class="hljs-number">12</span>)<br><span class="hljs-comment">#pytoch</span><br>x = torch.arange(<span class="hljs-number">12</span>)<br><span class="hljs-comment">#tensorflow</span><br>x = tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><h4>张量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#张量的形状(shape)是一个整数元组，表示张量的轴数以及每个轴含的元素个数</span><br><br><span class="hljs-comment">#如（3，5）表示一个2(Dimension)维张量,型如下:</span><br>y = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<br>[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],<br>[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]<br>])<br><span class="hljs-comment">#pytorch：  torch.tensor([])</span><br><span class="hljs-comment">#tf:      tf.constant([])</span><br><span class="hljs-comment">#如(3,3,5)型如下:</span><br>z = np.array([[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]<br>],[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]],<br>[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]]])<br><span class="hljs-comment">#通过shape属性查看张量的形状</span><br><span class="hljs-built_in">print</span>(y.shape)<br><span class="hljs-comment">#reshape函数可以更改张量的形状同时不改变张量的内容</span><br>X = x.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment">#使用时还可以用-1来自动算出维度,但注意只能指定一位未知维度</span><br>Y = y.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-comment">#tf中X = tf.reshape(X,(-1,3,5))</span><br><span class="hljs-comment">#使用ones,zeros函数可以将张量的元素初始化为全1全0,传入的是shape元组</span><br>np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br>np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment">#从概率分布中获取随机初始化的值，例子如下(这是一个shape为(3,4)的张量，其中元素都是从高斯分布中采样)</span><br><span class="hljs-comment">#0是均值，1是标准差</span><br>np.random.normal(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,size=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment">#pytorch:     torch.randn(3,4)</span><br><span class="hljs-comment">#tf: tf.random.normal(shape=[3,4])</span><br><span class="hljs-comment">#张量的大小是指张量中所含的元素个数</span><br><span class="hljs-built_in">print</span>(y.size)<br><span class="hljs-comment"># pytorch 中用numel()查看size，tensorflow中则用tf.size(X)查看</span><br><br><span class="hljs-comment">#张量中所包含的数据类型通常叫dtype,张量的类型可以是 float32、uint8、float64 等\</span><br><span class="hljs-built_in">print</span>(y.dtype)<br></code></pre></td></tr></table></figure><h4>运算符</h4><p>按元素运算时，需要两个张量同形,运算就是同一位置的进行运算，x+y,x-y,x/y,x*y,x**y，按元素运算还可使用一些一元运算符，如求e的幂，可采用np.exp(x),(x为之前定义的张量),除按元素运算外还可以执行线性代数运算。也可以把多个张量连结起来，只需指定连结的轴.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">X = x.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>Y = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],<br>[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>]<br>])<br><span class="hljs-comment">#axis=0 按行连结;axis=1 按形状的第二个元素连结</span><br>np.concatenate([X,Y],axis = <span class="hljs-number">0</span>)<br><span class="hljs-comment"># pytorch:   X = torcch.arrange(12,dtype=torch.float32).reshape((3,4))   torch,cat((X,Y),dim=0)</span><br><span class="hljs-comment">#tf: X = tf.reshape(tf.range(12,dtype=tf.float32),(3,4))      tf.concat([X,Y],axis = 0)</span><br></code></pre></td></tr></table></figure><p>可以通过X==Y构造二元张量，及只有true或者false，但需要xy同形.sum()函数对张量中所有元素求和。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(X==Y)<br><span class="hljs-built_in">print</span>(X&lt;Y)<br><span class="hljs-built_in">print</span>(X&gt;Y)<br><span class="hljs-built_in">print</span>(X.<span class="hljs-built_in">sum</span>())<br><span class="hljs-comment">#tf: tf.reduce_sum(X)</span><br></code></pre></td></tr></table></figure>在计算不同形状的张量时，可通过调用广播机制进行<strong>按元素运算</strong>，广播机制通过将张复制扩展使得不同形状的张量扩展为同一形状的张量。例如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个3×1和1×2的矩阵相加</span><br>a = np.arrange(<span class="hljs-number">3</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>b = np.arrange(<span class="hljs-number">2</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(a+b)<br><span class="hljs-comment">#可以发现a复制了列，b复制了行再相加的</span><br></code></pre></td></tr></table></figure>张量也可用索引切片访问，同python数组一样，可用-1访问最后一位元素。[1：3]访问第二和第三位元素，还可通过索引写入元素<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>,:] = <span class="hljs-number">12</span><br><span class="hljs-comment">#上是取1和2行并将行中全部写入12</span><br></code></pre></td></tr></table></figure>在运行一些操作时比如Y=X+Y时不会在原地运行，而是会新开辟内存来保存X+Y的值，这样的话会导致一个是数据大的时候会额外占用大量内存，二是过去的旧引用会找不到新的内容，因此为了避免以上，可用切片表示法将结果分配给之前分配的数组实现原地执行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#新建一个和Y同形的全0块，再把X+Y的值赋给Z，能看到实现了原地执行</span><br>Z = np.zeros_like(Y)<br><span class="hljs-comment">#id()查看地址</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(Z))<br>Z[:] = X + Y<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(Z))<br><br></code></pre></td></tr></table></figure>将深度学习框架定义的张量转换为numpy张量不共享内存，可用item函数或者python内置函数进行转换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">3.5</span>])<br>a.item()<br><span class="hljs-built_in">float</span>(a)<br><span class="hljs-built_in">int</span>(a)<br></code></pre></td></tr></table></figure></p><h1 id="数据预处理">数据预处理</h1><p>使用pandas软件包预处理原始数据，并转化为张量</p><h2 id="读取数据集">读取数据集</h2><p>创建一个我们将要处理的csv文件os库中相关函数内容查阅<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[os库](https://docs.python.org/zh-cn/3/library/os.path.html)">[3]</span></a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入python标准库的os模块，os模块提供了对文件操作路径访问等操作的支持</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment">#创建一个目录，makedirs和mkdir的区别在于makedirs会自动创建父目录而mkdirs不存在父目会报错</span><br>os.makedirs(os.path.join(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;data&#x27;</span>),exist_ok=<span class="hljs-literal">True</span>)<br>data_file = os.path.join(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;house_tiny.csv&#x27;</span>)<br><span class="hljs-built_in">print</span>(data_file)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_file,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="hljs-comment"># 列名</span><br>    f.write(<span class="hljs-string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="hljs-comment"># 每行表示一个数据样本</span><br>    f.write(<span class="hljs-string">&#x27;2,NA,106000\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;4,NA,178100\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;NA,NA,140000\n&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>导入pandas包并调用read_csv函数查看数据内容 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>data_file = <span class="hljs-string">&#x27;./data/house_tiny.csv&#x27;</span><br>data = pd.read_csv(data_file)<br><span class="hljs-built_in">print</span>(data)<br><br>```  <br><br><span class="hljs-comment">## 处理缺失值</span><br>常采用插值法和删除法，插值法用一个替代值补缺失值，而删除法则是直接忽略缺失值。此处主要用插值法。<br>这里会用到pandas中的iloc函数简单介绍一下。<br>iloc使用行列的索引位置来寻找值 <br><br>```python<br><span class="hljs-comment">#读取第二行的值</span><br>data1 = data.iloc[<span class="hljs-number">1</span>]<br><span class="hljs-comment">#读取第二列的值</span><br>data2 = data.iloc[:,<span class="hljs-number">1</span>]<br><span class="hljs-comment">#进行切片操作</span><br>data3 = data.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></p><p>与iloc相似的是loc，区别是loc用名称或者标签进行索引。通过iloc把数据分为inputs和outputs，inputs为数据前两列，outputs为最后一列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = data.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>outputs = data.iloccc[:,-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>对于inputs中缺少的数值，用同一列的均值替换'NaN'项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = inputs.fillna(inputs.mean())<br><span class="hljs-built_in">print</span>(inputs)<br></code></pre></td></tr></table></figure><p>numpy中get_dummies会实现独热编码，独热编码又称为一位有效编码，主要是采用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。适用于分类特征，将其特征数值化，例如此处的巷子类型，只有pave和nan，那么就会有两列一列是alley_pave一列是alley_nan，类型是pave的这一行就会显示为10 ，而没有的则会显示0 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = pd.get_dummies(inputs,dummy_na = <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(inputs)<br></code></pre></td></tr></table></figure><h2 id="转换为张量格式">转换为张量格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> mxnet <span class="hljs-keyword">import</span> np<br>X = np.array(inputs.to_numpy(dtype=<span class="hljs-built_in">float</span>))<br>y = np.array(outputs.to_numpy(dtype = <span class="hljs-built_in">float</span>))<br><br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://www.nvidia.cn/glossary/data-science/mxnet/">什么是Apache MXNet？</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://zh.d2l.ai/index.html">动手学深度学习</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://docs.python.org/zh-cn/3/library/os.path.html">os库</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Regression</title>
    <link href="/2024/07/27/Linear-Regression/"/>
    <url>/2024/07/27/Linear-Regression/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据集是用于线性回归计算的薪资数据集，csv格式只有工作年限(YearsExperience)和薪资(Salary)主要采用了numpy和matplotlib库实现代码。 # 基本内容线性回归模型属于监督型模型，一维的linear regression model是<br /><span class="math display">\[E=mc^2\]</span> ##</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔一篇</title>
    <link href="/2024/07/26/wrinting727/"/>
    <url>/2024/07/26/wrinting727/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="788cb2a8e8c7c4fbc82e66ec0ace438475d60d5c5766e12de8468340d3536a4d">4630436162ade97ba2718b7d0c4b3b630ef8b034c35893a7afa4c54a5752d90eba191a593f89497fdfca691efaf72d5caa0c664d8e7a85bd833fac72ade59ddbf66b4bdec75a2ed1e83f57bcb279b78c8202c7ce8d3eb34051070935a62ccbf9be563b576fcb19a6e4c095e03496f05d0fec5de7a8af18b78d977beffb6874da4670293f572d11dfa81b48ce6cd0448f0a018d399d177f54eb76d77c6c17f9c36f9f255c3de0f225f9e9c6b4f23d83fc3307cf9be8ef0d2bb8d0474ceec45d7300894f4b8f11650b44ad991ba7d43228d49371fdc826ee64ef965f7f9da75f1bada747e79a3b422cc1d5f2e2094c9e669283cc6dbb839e4fb6adaaaab5a5df04ed7e145022c07c48821baf1e8eeb22999bf71199586896cf90fed2c983728db62230bda10d972c764e3229e40cc3e9c2541a4361f8d1a48dbfff41a49a2ad2ec7a8a9a786c104ee6aa8b713533888cc2cce330aeab25b78d8300740003e714909912e968f1a91cf0db07b69ec70cbf88bd97ef98be8310f0609a5712952391951659063d205b75d1d8add4fe57ddae38cf425a5c59014b6e392754259a3607d24b3e51b74a393fc2c30faffd796c45c2e16dfb1fcd85ecdc70fa1231de549223159a4753281af9e2e07fe558324371b491c7df64f3aa823290f09df228a1232d5677754bd5dfa1d3e47185e16b217229e68aa5b2565cdd2d14d4d94c9aa15c0dd891418aa160fe6f638be11c14aad06e6b48449b24c967751b6ecf5863be6899aed5a031c69384543c799102ac2c59e6b2c26044244a1244305adef304ff2e7e6ead54699560d7ea591ffa4c6bd7c8a613dd3ff4d24cef2673937152b2163f26801d29536611a5c2432e676c1e4a1accbb98dc0a35865940235cfb8a172618083e7a8ae10ac2359e46376733f48386989be11e2f2a6f7ebb9f28f6f8f34aeeadcb41a60753ea00faf21368583cc068d00be590ea704770f6415c5bfbec1e53db027edca476310839423ccd6b2d3d7c127fd3f5d4619d399f4bc64dc942a67e101f6b7aea2848397105ff7eba363e0acd5a5540f60a78a7a35ba91590f4efa861b7e5cdeada7c5aa0036f665c8fab3d6bbb2aa009db2ad719644664f902f83d88e61d9314ab16bf9d322392e95c8946747c83c81f2e4b50370559bd3e525e53b7a8b31c802846a6da4fbbe3aeb69f6e3323af8a2def0f4f23f169d850ff5be5e9c50cbb51568aeb3c9977cc10b9a2bdd995273e5e4cc2938197cc9d20d8c4d95d9a7c9907b9c9ae7c6558457e0970eaef267cf9abb8322a80fec3dfc291131514c8a788d24ed9d17b1245a6d1daf26574b246f4bf6166f70c39cd6ff6a26664eb14b9035e660ae22d4b440570384b21e55c3d1d3fe9a060f583eb89f8a05a5dba1e73ada8b30187f4f72e5b06837aed42c233d79f146f6e60f5af4b7026b0b8f22fd40ad8ef81d604698508f9c13bae6a2604ee4971ba70c6dab47204973760bd9e2f1b89a9b5c3552b4df7728163a6e9f5ecc6544e2f55726ddbf343c44f1a6fd0742655c44c18926270b59ac87546090c22613c7fc96833562e7ff5224ddb4143b45b8f8e3b548e8901d4e162505ed1ee2ca3250dbf3c21738ada311adc3b205244ae9a9c09e78396fd916b368891b8e54f034139c08f7e8b7fe5bc37d4de184fe1440d7c068b4c3566bbdfe675ba3d96eeec3edafdd9daf8233904c41b7645aa342e9ce4dd0bf1960110d3f408bce77c2c7d27d9c3250ccf28706efe12eaa76a25792eaeb14c0f7de28fdb4e2533297e6554a7d9a6cc4ac326d3acb4f42ad7701a63e7edaed04e17d0c21b77f02487bd7ee97c4f92742fcae758e959d5898f8fbdcf4a48bc56a0fb7d28067f88e076f3eeaa181520af493fa6d2830d5a7067f51184f940140696c61b8048690d9454ea3927836163d373bd7596a3b758444a42a1e1a842dd4ad728f94de8e333603e4ac4b2f6d1a7f8edcd563c5cf4af229cfbd70cf9abb4f93a81b9ed1707095469b790c0e09f6a3685836c3001483dfa9e2780f03436d001148251c6568e0fc9a187da95bef7dbac9bdc1de94132b7776a22103c634480a3a2f2d30d3b3769d844d02153ea1d5570cacae7578a43f83e931b03ec5cf205e95d9d754576411e7cc713b59129417ed96ef66c9e561eb45e39005c9e6a6d81b16cc2a1252d464898bb789209ac53fc016123a22ccc945666bc4211abf517462b4c667010f7da80830b4c502af4cb11e64b40e756208d2412e446bbed210e54b1dea5265df7fe6f2092</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作练习</tag>
      
      <tag>每日一篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blender学习记录之自动售货机</title>
    <link href="/2024/07/26/blender2/"/>
    <url>/2024/07/26/blender2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文链接在这里：<ahref="https://youtu.be/BzTN2yTgTj0?si=S0nUNVi2O9fATo_W">My Blender 2D/3DProcess with Grease Pencil</a></p><p>最后建的模型有问题，先保留，完成简单的之后再继续。 # 建模</p><p>首先先建立一个自动售货机的大体模型，shift+a建立一个cube，一个cylinder，然后通过倒角shift+b和缩小cylinder底面实现下图,再创建填充后的一个circle（可以采用在编辑模式按f或者左下角把fill-type设置为N-GON(因为我用的英文版)）</p><figure><img src="/img/blenderpic/blender2-1.png" alt="模型" /><figcaption aria-hidden="true">模型</figcaption></figure><p>再创建一个camera，用于观察，通过坐标轴下边的camera图标进入相机镜头，将camera和view绑定，找到一个合使的观察位置，分割两个视角(在边缘处点击右键选择verticalsplit)，一个用于摄像机，一个用于建模，如下图<br /><img src="/img/blenderpic/blender2-2.png" alt="模型2" /></p><p>在主体模型上挖两个坑，都是用内插面i＋挤压e实现，再给上面的坑加上货架cube实现,添加modifier，array，下图是我的设置<br /><img src="/img/blenderpic/blender2-3.png" alt="模型3" /></p><p>以下图为例创建三个panel，采用ctrl+F2可以给创建好的快速重命名，建好后都加入集合，可以适当将machine的顶部放大，最后按a全选右键选择shadeauto smooth <img src="/img/blenderpic/blender2-4.png" alt="模型4" /></p><p>接着在machine上建按钮，采用两个modifier实现按钮的排列,完成后做出不同类型的瓶子。放入machine中</p><h1 id="material">material</h1><p>将左下角的mode改为ShaderEditor,添加sun，调整角度，选中machine在mode里新建material</p><p>在采用 line art时出现问题，暂未解决，问题如下: <imgsrc="/img/blenderpic/blender2-5.png" alt="模型5" />模型有部分未被线条包围有些不该出现线条的地方产生了线条。。</p><p>此文暂存！</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blender学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blender学习记录之Smooth 3D living room</title>
    <link href="/2024/07/25/blender1/"/>
    <url>/2024/07/25/blender1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下学习blender的学习过程,这个模型是按照油管上的一个博主的内容做的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Blender 3D Beginner Tutorial: Smooth 3D Living Room](https://youtu.be/dEGJeVnWZAA?si=eq0xsQRhnSmW-qhl)">[1]</span></a></sup>，</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://youtu.be/dEGJeVnWZAA?si=eq0xsQRhnSmW-qhl">Blender3D Beginner Tutorial: Smooth 3D Living Room</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blender学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
