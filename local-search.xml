<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>滑动窗口实现</title>
    <link href="/2024/10/31/%E5%88%B7%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/10/31/%E5%88%B7%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注意点">注意点</h1><p>1、窗口内的内容； 2、如何移动窗口起始位置 3、如何移动窗口结束位置</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文记住二分查找法</title>
    <link href="/2024/10/28/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/10/28/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mor">记忆方法</h1><p>1、判断点 &gt;= 或 &gt;</p><p>2、边界点位置 0~len-1 or 0~len</p><p>3、左右边界的情况 mid -1、mid+1 or mid+1</p><h1 id="二分查找法">二分查找法</h1><p>二分查找法的关键在于区间的选取，不同区间选取导致不同结果，容易忽略某些位置导致计算不到的情况。这里主要是叙述一个左闭右闭区间和左闭右开区间作为例子。</p><h2 id="左闭合右闭合区间">左闭合右闭合区间</h2><p>这里的关键是要理解，当左尽头端点属于范围内，右尽头端点也属于范围内时，此时我们设想一种极端情况，这时候已经查找到最后一个点，左右标识都是指向这一个点，那么我们判不判断这个点，答案是判断，那么为什么呢？很简单，这个时候只要想着左区间尽头是这个点，右区间尽头也是这个点，那么这个点是包含在查找范围内的，那我们当然要判断这个点属不属于范围内部，因此，我们在这种情况下的判断范围应该是<strong>left&gt;=right</strong>，这是<strong>第1个</strong>需要注意的点。<strong>其次</strong>就是right和left的值，因为是包含left和right的，所以他们的值就应该是尽头的位置。<strong>第3点</strong>就是在判断边界点时应该如何操作，首先在这个算法中我们有两个边界点，一个left，一个right，那么在更新中点时，left和right值该如何选取呢，首先我们先考虑left，也就是左边界，当我们需要判断的数值大于这个中间值时，代表着这个数值是在中间值的右边，那么我们就应该把left更新到中间点处，直接使用left=mid这样的表达正确吗？如果你这样表达就刚好踩入了第一个坑，因为，根据我们之前所叙述的内容，这里的mid实际上是已经判断过的点，那么之后我们便不会再判断这个点，故我们需要把left的值右移一位也就是说<strong>left= mid+1</strong>，同理，对于右边界的点也是做同样处理变为<strong>right =mid-1</strong>这里因为刚好是左移一位。到目前位置，所以需要注意的点我们都考虑到了，接下来就是代码实现了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在这里nums是我们要查找的有序数组，千万注意一定是有序的！</span><br><span class="hljs-comment"># target即我们的目标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search_1</span>(<span class="hljs-params">nums,target</span>):<br>    left = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#这里right应该减1，因为nums是从0到len(nums)-1的，而非1到len(nums)</span><br>    right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>    <span class="hljs-comment">#这里right必须大于等于left，理由我们已经解释过了</span><br>    <span class="hljs-keyword">while</span> right &gt;= left:<br>    <span class="hljs-comment">#这里计算mid的值，这样计算的原因是只计算（right - left)//2只是计算了二者之间的距离，还得加上</span><br>    <span class="hljs-comment">#之前的基准，就像我们曾经学过的计算直角坐标系上两个正x值之间的中点的x坐标。//表示取整</span><br>        mid = left +(right-left)//<span class="hljs-number">2</span><br>    <span class="hljs-comment">#进入判断语句，根据我们之前的分析进行编写</span><br>        <span class="hljs-keyword">if</span>(nums[mid]==target):<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span>(nums[mid]&gt;target):<br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span> :<br>            left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-comment">#循环结束后还没返回证明目标不在数组中，故返回-1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <br></code></pre></td></tr></table></figure></p><h2 id="左闭合右开区间">左闭合右开区间</h2><p>在这种情况中我们也是主要对我在<ahref="#mor">记忆方法</a>模块提到的三个地方进行注意，首先这个地方判断没有包含=号，用同样的方法理解，这个中点实际上是不需要判断，因为不包含它，而第二点选择0~len是因为右边是开区间，故不能直接等于尽头，如果直接等于就是闭区间了，最后一个情况是因为我们只需要考虑在左边的点是会被判断的情况，故左边的更新为中点时，则需要将其括出去，故为left+1.综上所述其代码如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在这里nums是我们要查找的有序数组，千万注意一定是有序的！</span><br><span class="hljs-comment"># target即我们的目标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search_2</span>(<span class="hljs-params">nums,target</span>):<br>     left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">while</span> right&gt;left:<br>            mid=left+(right - left) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid]==target:<br>                <span class="hljs-keyword">return</span> mid<br>            <span class="hljs-keyword">elif</span> nums[mid]&gt;target:<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>箱型图</title>
    <link href="/2024/10/08/matlab/datanalyse/"/>
    <url>/2024/10/08/matlab/datanalyse/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="箱型图">箱型图</h1><p>源码数据在GitHub本文件夹的source下边，对餐饮系统的销售额数据进行处理。采用箱型图检测异常值。代码中xls文件和代码处于同一个文件夹中.这里计算四分位箱图上下界时采用常数1.5是因为使用1.5 倍的 IQR来定义上下限的做法源于经验法则，主要是为了平衡灵敏度与稳健性。一些情况下也有用其他值的，值越大定义的异常值标准越宽松</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs matab">catering_sale = &#x27;catering_sale.xls&#x27;;<br>index = 1;  %用于后面提取第一列数据<br>%% 读入数据<br>[num,txt] = xlsread(catering_sale); %通过xlsread获取到文件中的数字和字符<br>sales = num(2:end,index);   %提取出num中从2到最后的第一列，之前定义了index=1<br>rows = size(sales,1); % 表示返回矩阵的第一维度也就是行，<br><br>%% 处理缺失值<br>nanvalue = find(isnan(sales));<br>if isempty(nanvalue)<br>    disp(&#x27;没有缺失值！&#x27;);<br>else <br>    row_ = size(nanvalue,1);%缺失值的行数，即缺失值数量<br>    disp([&#x27;缺失值个数为:&#x27; num2str(row_) &#x27;,缺失率为:&#x27; num2str(row_/rows)])%方括号 [] 可以将字符串和通过 num2str 转换为字符串的数值拼接在一起，形成一个完整的输出字符串<br>end<br><br>%% 设置箱型图属性<br>q_ = prctile(sales,[25,75]);%获取百分位数，这里是四分位箱图所需的上四分位和下四分位位置<br>p25 = q_(1,1);%获取上四分位数<br>p75 = q_(1,2);%下四分位数<br>% 四分位距 (IQR)：计算方法为 p75 - p25<br>upper = p75+1.5*(p75-p25);%计算上界,1.5是一个常用的常数，用于定义异常值的边界。<br>lower = p25-1.5*(p75-p25);%计算下界<br>upper_indexes = sales(sales&gt;upper);%返回一个逻辑数组，sales中如果大于upper返回true，再取出sales中取true的值<br>lower_indexes = sales(sales&lt;lower);% 同理<br>indexes = [upper_indexes;lower_indexes];%upper_indexes 和 lower_indexes 垂直拼接在一起，生成一个新的数组 indexes，其中全为异常的值，确保都是列向量，如果不是可用&#x27;转置<br>indexes =sort(indexes);%对indexes进行排序，返回一个升序<br>%% 画箱型图<br>figure<br>hold on;%新图可以叠加在旧图上<br>boxplot(sales,&#x27;whisker&#x27;,1.5,&#x27;outliersize&#x27;,6); %whisker是指定须的长度，须由IQR决定，IQR是上四分位数与下四分位数之差。<br>%须指的是延伸至最小非异常值和最大非异常值。outliersize 控制异常值的标记大小，便于突出异常数据点<br>rows = size(indexes,1);%返回indexes的大小<br>flag = 0;%用于控制文本标注的位置<br>for i = 1:rows %遍历所有的异常值<br>    if flag == 0<br>        text(1+0.01,indexes(i,1),num2str(indexes(i,1)));%text用于在指定位置添加文本，<br>        %第一个参数是x坐标，后面是y坐标即文本标记在异常值当前所在位置，最后一个参数将数值转换为字符串在图中表示出<br>        flag = 1;%下一次循环换一个位置标注<br>    else <br>        text(1-0.017*length(num2str(indexes(i,1))),indexes(i,1),num2str(indexes(i,1)));<br>        %根据文本长度计算x坐标，确保不重叠，后面两个参数同理<br>        flag = 0;<br>    end<br>end<br>hold off;<br>disp(&#x27;餐饮销售数据缺失值及异常值检测完成！&#x27;)<br><br></code></pre></td></tr></table></figure><p>结果如下： <img src="/img/matlabpic/boxplot_sale.png"alt="results" /></p><p>以下是一些修改箱型图外观的方法 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab">boxplot(data, <span class="hljs-string">&#x27;Colors&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;Widths&#x27;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-string">&#x27;Whisker&#x27;</span>, <span class="hljs-number">1.5</span>, ...<span class="hljs-string">&#x27;Symbol&#x27;</span>, <span class="hljs-string">&#x27;k*&#x27;</span>, <span class="hljs-string">&#x27;OutlierSize&#x27;</span>, <span class="hljs-number">8</span>);<br><span class="hljs-comment">%&#x27;Colors&#x27;：设置箱线图的颜色。可以使用颜色字符（如 &#x27;r&#x27; 表示红色）或 RGB 数组（如 [0, 0, 1] 表示蓝色）。</span><br><span class="hljs-comment">%&#x27;Widths&#x27;：控制箱体的宽度，默认值为 0.5,&#x27;Symbol&#x27;：定义异常值的符号样式，如 &#x27;k*&#x27; 表示黑色星号。</span><br><span class="hljs-comment">%可以使用 findobj 函数查找并修改特定的图形对象，例如箱体、中位数线和须</span><br><span class="hljs-comment">% 修改箱体的颜色为蓝色</span><br>set(findobj(h, <span class="hljs-string">&#x27;Tag&#x27;</span>, <span class="hljs-string">&#x27;Box&#x27;</span>), <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><br><span class="hljs-comment">% 修改中位数线的颜色为红色</span><br>set(findobj(h, <span class="hljs-string">&#x27;Tag&#x27;</span>, <span class="hljs-string">&#x27;Median&#x27;</span>), <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;LineWidth&#x27;</span>, <span class="hljs-number">1.5</span>);<br><br><span class="hljs-comment">% 修改须的颜色为绿色</span><br>set(findobj(h, <span class="hljs-string">&#x27;Tag&#x27;</span>, <span class="hljs-string">&#x27;Whisker&#x27;</span>), <span class="hljs-string">&#x27;Color&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;LineStyle&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span>);<br><br><span class="hljs-comment">% 修改异常值的标记为紫色圆圈</span><br>set(findobj(h, <span class="hljs-string">&#x27;Tag&#x27;</span>, <span class="hljs-string">&#x27;Outliers&#x27;</span>), <span class="hljs-string">&#x27;MarkerEdgeColor&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>);<br><br><span class="hljs-comment">% 要为箱线图的箱体添加填充颜色，可以使用 patch 函数：</span><br><span class="hljs-comment">% 获取箱体对象并添加填充颜色</span><br>boxes = findobj(gca, <span class="hljs-string">&#x27;Tag&#x27;</span>, <span class="hljs-string">&#x27;Box&#x27;</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(boxes)<br>    patch(get(boxes(<span class="hljs-built_in">j</span>), <span class="hljs-string">&#x27;XData&#x27;</span>), get(boxes(<span class="hljs-built_in">j</span>), <span class="hljs-string">&#x27;YData&#x27;</span>), <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;FaceAlpha&#x27;</span>, <span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure> findobj(gca, 'Tag','Box') 会查找当前坐标轴（gca）中所有 Tag 为 'Box' 的对象 findobj根据对象的 Tag属性来找到特定的图形元素，例如箱体（Box）、中位数线（Median）、须（Whisker）等。MATLAB自动为不同的图形元素设置了特定的 Tag属性，这些属性可以用来查找和修改这些元素。例如：</p><ul><li>箱体的 <code>Tag</code> 属性为 <code>'Box'</code></li><li>中位数线的 <code>Tag</code> 属性为 <code>'Median'</code></li><li>须的 <code>Tag</code> 属性为 <code>'Whisker'</code></li><li>异常值的 <code>Tag</code> 属性为 <code>'Outliers'</code></li></ul><p>其中，h 是一个图形对象或对象的句柄（handle）。当使用 boxplot函数创建箱线图时，可以将返回的句柄赋给变量h，以便以后对图形的各个元素进行访问和修改。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习预备知识</title>
    <link href="/2024/07/28/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/07/28/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习的是李沐的《动手学深度学习》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[动手学深度学习](https://zh.d2l.ai/index.html)">[2]</span></a></sup></p><h1 id="深度学习框架">深度学习框架</h1><p>先主要了解三个深度学习框架，MXNET、PYTORCH、TENSORFLOW。</p><h2>MXNET</h2><p>MXNet是开源深度学习框架，允许用户在多种设备（无论是云基础设施还是移动设备）上定义、训练和部署深度神经网络。该框架具备高度可扩展性，可以进行快速的模型训练，并支持灵活的编程模型和多种语言。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[什么是 Apache MXNet？](https://www.nvidia.cn/glossary/data-science/mxnet/)">[1]</span></a></sup>。它于2015年由亚马逊团队开发。这里就介绍命令行安装方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install mxnet   <br><span class="hljs-comment">#GPU版本的MXNet:</span><br>pip install mxnet-cu111<br></code></pre></td></tr></table></figure><p>导包不出错则证明安装成功。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入np和npx模块，np模块包含了numpy支持的函数，而npx模块则包含了一些扩展函数</span><br><span class="hljs-keyword">from</span> mxnet <span class="hljs-keyword">import</span> np,npx<br><span class="hljs-comment">#在使用张量之前基本上都会调用下面这个函数，目的是为了兼容mxnet的其他张量处理</span><br>npx.set_np()<br><br></code></pre></td></tr></table></figure></p><h2>PYTORCH</h2><p>PyTorch是一个由Facebook的人工智能研究团队开发的开源深度学习框架PyTorch最突出的优点之一就是它使用了动态计算图（Dynamic ComputationGraphs，DCGs），提供了大量的预训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install torch   <br></code></pre></td></tr></table></figure><p>安装完成后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#直接导入</span><br><span class="hljs-keyword">import</span> torch <br></code></pre></td></tr></table></figure><h2>TENSORFLOW</h2><p>TensorFlow是由GoogleBrain团队开发的开源机器学习框架，致力于数据流图的自动微分和深度神经网络计算。它跨平台且灵活，广泛用于构建、训练和部署机器学习模型.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install tensorflow   <br></code></pre></td></tr></table></figure><p>安装完成后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#直接导入</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf <br></code></pre></td></tr></table></figure><h2 id="基本使用">基本使用</h2><h4>什么是张量</h4><p>张量就是一些数值组成的数组，比如说0维张量就是指一个数，数组中只保存了一个数字，又称为标量，可以用ndim属性来查看一个数组的轴的个数，对于轴数的一个简单判断方法就是看第一个数字前面有几个[]括号，所以在标量中只有一个数因此标量中的ndim==0，1维张量就是我们所熟知的向量，2维张量俗称矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#张量的构造方法,以下构造了一个0-11的十二位一维张量。</span><br><span class="hljs-comment">#MXNET</span><br>x = np.arange(<span class="hljs-number">12</span>)<br><span class="hljs-comment">#pytoch</span><br>x = torch.arange(<span class="hljs-number">12</span>)<br><span class="hljs-comment">#tensorflow</span><br>x = tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><h4>张量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#张量的形状(shape)是一个整数元组，表示张量的轴数以及每个轴含的元素个数</span><br><br><span class="hljs-comment">#如（3，5）表示一个2(Dimension)维张量,型如下:</span><br>y = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<br>[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],<br>[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]<br>])<br><span class="hljs-comment">#pytorch：  torch.tensor([])</span><br><span class="hljs-comment">#tf:      tf.constant([])</span><br><span class="hljs-comment">#如(3,3,5)型如下:</span><br>z = np.array([[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]<br>],[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]],<br>[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>]]])<br><span class="hljs-comment">#通过shape属性查看张量的形状</span><br><span class="hljs-built_in">print</span>(y.shape)<br><span class="hljs-comment">#reshape函数可以更改张量的形状同时不改变张量的内容</span><br>X = x.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment">#使用时还可以用-1来自动算出维度,但注意只能指定一位未知维度</span><br>Y = y.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-comment">#tf中X = tf.reshape(X,(-1,3,5))</span><br><span class="hljs-comment">#使用ones,zeros函数可以将张量的元素初始化为全1全0,传入的是shape元组</span><br>np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br>np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment">#从概率分布中获取随机初始化的值，例子如下(这是一个shape为(3,4)的张量，其中元素都是从高斯分布中采样)</span><br><span class="hljs-comment">#0是均值，1是标准差</span><br>np.random.normal(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,size=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-comment">#pytorch:     torch.randn(3,4)</span><br><span class="hljs-comment">#tf: tf.random.normal(shape=[3,4])</span><br><span class="hljs-comment">#张量的大小是指张量中所含的元素个数</span><br><span class="hljs-built_in">print</span>(y.size)<br><span class="hljs-comment"># pytorch 中用numel()查看size，tensorflow中则用tf.size(X)查看</span><br><br><span class="hljs-comment">#张量中所包含的数据类型通常叫dtype,张量的类型可以是 float32、uint8、float64 等\</span><br><span class="hljs-built_in">print</span>(y.dtype)<br></code></pre></td></tr></table></figure><h4>运算符</h4><p>按元素运算时，需要两个张量同形,运算就是同一位置的进行运算，x+y,x-y,x/y,x*y,x**y，按元素运算还可使用一些一元运算符，如求e的幂，可采用np.exp(x),(x为之前定义的张量),除按元素运算外还可以执行线性代数运算。也可以把多个张量连结起来，只需指定连结的轴.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">X = x.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>Y = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],<br>[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>]<br>])<br><span class="hljs-comment">#axis=0 按行连结;axis=1 按形状的第二个元素连结</span><br>np.concatenate([X,Y],axis = <span class="hljs-number">0</span>)<br><span class="hljs-comment"># pytorch:   X = torcch.arange(12,dtype=torch.float32).reshape((3,4))   torch,cat((X,Y),dim=0)</span><br><span class="hljs-comment">#tf: X = tf.reshape(tf.range(12,dtype=tf.float32),(3,4))      tf.concat([X,Y],axis = 0)</span><br></code></pre></td></tr></table></figure><p>可以通过X==Y构造二元张量，及只有true或者false，但需要xy同形.sum()函数对张量中所有元素求和。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(X==Y)<br><span class="hljs-built_in">print</span>(X&lt;Y)<br><span class="hljs-built_in">print</span>(X&gt;Y)<br><span class="hljs-built_in">print</span>(X.<span class="hljs-built_in">sum</span>())<br><span class="hljs-comment">#tf: tf.reduce_sum(X)</span><br></code></pre></td></tr></table></figure>在计算不同形状的张量时，可通过调用广播机制进行<strong>按元素运算</strong>，广播机制通过将张复制扩展使得不同形状的张量扩展为同一形状的张量。例如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个3×1和1×2的矩阵相加</span><br>a = np.arange(<span class="hljs-number">3</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>b = np.arange(<span class="hljs-number">2</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(a+b)<br><span class="hljs-comment">#可以发现a复制了列，b复制了行再相加的</span><br></code></pre></td></tr></table></figure>张量也可用索引切片访问，同python数组一样，可用-1访问最后一位元素。[1：3]访问第二和第三位元素，还可通过索引写入元素<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>,:] = <span class="hljs-number">12</span><br><span class="hljs-comment">#上是取1和2行并将行中全部写入12</span><br></code></pre></td></tr></table></figure>在运行一些操作时比如Y=X+Y时不会在原地运行，而是会新开辟内存来保存X+Y的值，这样的话会导致一个是数据大的时候会额外占用大量内存，二是过去的旧引用会找不到新的内容，因此为了避免以上，可用切片表示法将结果分配给之前分配的数组实现原地执行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#新建一个和Y同形的全0块，再把X+Y的值赋给Z，能看到实现了原地执行</span><br>Z = np.zeros_like(Y)<br><span class="hljs-comment">#id()查看地址</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(Z))<br>Z[:] = X + Y<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(Z))<br><br></code></pre></td></tr></table></figure>将深度学习框架定义的张量转换为numpy张量不共享内存，可用item函数或者python内置函数进行转换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">3.5</span>])<br>a.item()<br><span class="hljs-built_in">float</span>(a)<br><span class="hljs-built_in">int</span>(a)<br></code></pre></td></tr></table></figure></p><h1 id="数据预处理">数据预处理</h1><p>使用pandas软件包预处理原始数据，并转化为张量</p><h2 id="读取数据集">读取数据集</h2><p>创建一个我们将要处理的csv文件os库中相关函数内容查阅<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[os库](https://docs.python.org/zh-cn/3/library/os.path.html)">[3]</span></a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入python标准库的os模块，os模块提供了对文件操作路径访问等操作的支持</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment">#创建一个目录，makedirs和mkdir的区别在于makedirs会自动创建父目录而mkdirs不存在父目会报错</span><br>os.makedirs(os.path.join(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;data&#x27;</span>),exist_ok=<span class="hljs-literal">True</span>)<br>data_file = os.path.join(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;house_tiny.csv&#x27;</span>)<br><span class="hljs-built_in">print</span>(data_file)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_file,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="hljs-comment"># 列名</span><br>    f.write(<span class="hljs-string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="hljs-comment"># 每行表示一个数据样本</span><br>    f.write(<span class="hljs-string">&#x27;2,NA,106000\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;4,NA,178100\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;NA,NA,140000\n&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>导入pandas包并调用read_csv函数查看数据内容 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>data_file = <span class="hljs-string">&#x27;./data/house_tiny.csv&#x27;</span><br>data = pd.read_csv(data_file)<br><span class="hljs-built_in">print</span>(data)<br><br>```  <br><br><span class="hljs-comment">## 处理缺失值</span><br>常采用插值法和删除法，插值法用一个替代值补缺失值，而删除法则是直接忽略缺失值。此处主要用插值法。<br>这里会用到pandas中的iloc函数简单介绍一下。<br>iloc使用行列的索引位置来寻找值 <br><br>```python<br><span class="hljs-comment">#读取第二行的值</span><br>data1 = data.iloc[<span class="hljs-number">1</span>]<br><span class="hljs-comment">#读取第二列的值</span><br>data2 = data.iloc[:,<span class="hljs-number">1</span>]<br><span class="hljs-comment">#进行切片操作</span><br>data3 = data.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></p><p>与iloc相似的是loc，区别是loc用名称或者标签进行索引。通过iloc把数据分为inputs和outputs，inputs为数据前两列，outputs为最后一列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = data.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>outputs = data.iloc[:,-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>对于inputs中缺少的数值，用同一列的均值替换'NaN'项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = inputs.fillna(inputs.mean())<br><span class="hljs-built_in">print</span>(inputs)<br></code></pre></td></tr></table></figure><p>numpy中get_dummies会实现独热编码，独热编码又称为一位有效编码，主要是采用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。适用于分类特征，将其特征数值化，例如此处的巷子类型，只有pave和nan，那么就会有两列一列是alley_pave一列是alley_nan，类型是pave的这一行就会显示为10 ，而没有的则会显示0 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs = pd.get_dummies(inputs,dummy_na = <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(inputs)<br></code></pre></td></tr></table></figure><h2 id="转换为张量格式">转换为张量格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> mxnet <span class="hljs-keyword">import</span> np<br>X = np.array(inputs.to_numpy(dtype=<span class="hljs-built_in">float</span>))<br>y = np.array(outputs.to_numpy(dtype = <span class="hljs-built_in">float</span>))<br><br></code></pre></td></tr></table></figure><h1 id="线性代数">线性代数</h1><p>主要了解一个是点乘，降维，向量积，矩阵乘法以及范数。</p><h3 id="点乘向量积矩阵乘法">点乘、向量积、矩阵乘法</h3><p>点乘主要是用计算向量乘积, 元素乘法再求和也可求出对应的值.<spanclass="math display">\[a,b\in R^d\]</span>矩阵乘法、向量积也是同样方法实现 <spanclass="math display">\[a^Tb=\sum_{i=1}^N a_ib_i\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>np.dot(x,y)<br></code></pre></td></tr></table></figure><h3 id="降维">降维</h3><p>求元素和可以达到降维的目的，使张量变为一个标量，还可以指定张量沿哪一个轴来通过求和降低维度，通过sum函数实现：sum(axis=0)指在0轴进行降维，指定轴数进行降维。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>a_sum_axis0 =a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>) <br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(a.shape)<br><br><br></code></pre></td></tr></table></figure><p>如果我们想沿某个轴计算A元素的累积总和，比如axis=0（按行计算），可以调用cumsum函数。此函数不会沿任何轴降低输入张量的维度。</p><h3 id="范数">范数</h3><p>向量的范数是表示一个向量有多大，即以特定的映射方式映射最后计算出的值进行比较，范数听起来很像距离的度量。范数简单来理解就是用于比较的，比如说一个坐标为(2,3)，另外一个坐标为(3,2)在这种情况下我们无法比较大小，那么就只有通过降维来达到我们的目的，将二者都降为一维。</p><h4 id="l_1范数"><span class="math inline">\(L_1\)</span>范数</h4><p><spanclass="math inline">\(L_1\)</span>范数是最常见的范数，其定义如下<spanclass="math display">\[\left\vert\left\vert x \right\vert\right\vert_1 =\sum_{i=1}^n\left\vert x_{i} \right\vert\]</span>即向量中所有元素绝对值之和，</p><h4 id="l_2范数"><span class="math inline">\(L_2\)</span>范数</h4><p><span class="math inline">\(L_2\)</span>范数定义如下：<spanclass="math display">\[\left\vert\left\vert x \right\vert\right\vert_2 =\sum_{i=1}^n\sqrt{\left\vert x_{i} \right\vert^2}\]</span></p><h4 id="l_p范数"><span class="math inline">\(L_p\)</span>范数</h4><p><span class="math inline">\(L_n\)</span>范数定义如下：<spanclass="math display">\[\left\vert\left\vert x \right\vert\right\vert_p =\sum_{i=1}^n\sqrt[p]{\left\vert x_{i} \right\vert^p}\]</span></p><h4 id="无穷范数">无穷范数</h4>所有元素中绝对值最大的 <span class="math display">\[\left\vert\left\vertx \right\vert\right\vert_\infty = \max(\left\vert x_1\right\vert,\left\vert x_2 \right\vert...\left\vert x_n\right\vert)\]</span> ## 参考<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://www.nvidia.cn/glossary/data-science/mxnet/">什么是Apache MXNet？</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://zh.d2l.ai/index.html">动手学深度学习</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://docs.python.org/zh-cn/3/library/os.path.html">os库</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Regression</title>
    <link href="/2024/07/27/Linear-Regression/"/>
    <url>/2024/07/27/Linear-Regression/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据集是用于线性回归计算的薪资数据集，csv格式只有工作年限(YearsExperience)和薪资(Salary)主要采用了numpy和matplotlib库实现代码。 # 基本内容线性回归模型属于监督型模型，一维的linear regression model是<br /><span class="math display">\[E=mc^2\]</span> ##</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔一篇</title>
    <link href="/2024/07/26/wrinting727/"/>
    <url>/2024/07/26/wrinting727/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="00df52fdd81615db52fcf24b54dc7b3dd6e9ea86e068d863f0aa8808e48a19e9">165d50f05814027fb7fe5e4ae8a088d8f56f9f99da4d666013e31ffb8bb0171fc7fb7e123a0dbdaace91d8f5befd348f68f3bcc4e96bdfebb15056a3980290f29c0c120b90ffb0cebc9c31a4d04c449736356c55b2d7373006ea60b2b254a672740e83f89b3c70817f925dad9048b6b6b1fc574cd4458bcf86b4ed6499fb3c4917e412d204a7e73de96aa06688e45d953d7749b7af00e9bd1af4bcbfb52c4c6db0c4779762facd60dac52625ee402bed23dd3b0f0f0345ac5f46272612607a94dbf19836afda7be5e91e19bf3cf903e221463cea95bf2f75f52dbdc4710f5849</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码查看</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作练习</tag>
      
      <tag>每日一篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blender学习记录之自动售货机</title>
    <link href="/2024/07/26/blender2/"/>
    <url>/2024/07/26/blender2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文链接在这里：<ahref="https://youtu.be/BzTN2yTgTj0?si=S0nUNVi2O9fATo_W">My Blender 2D/3DProcess with Grease Pencil</a></p><p>最后建的模型有问题，先保留，完成简单的之后再继续。 # 建模</p><p>首先先建立一个自动售货机的大体模型，shift+a建立一个cube，一个cylinder，然后通过倒角shift+b和缩小cylinder底面实现下图,再创建填充后的一个circle（可以采用在编辑模式按f或者左下角把fill-type设置为N-GON(因为我用的英文版)）</p><figure><img src="/img/blenderpic/blender2-1.png" alt="模型" /><figcaption aria-hidden="true">模型</figcaption></figure><p>再创建一个camera，用于观察，通过坐标轴下边的camera图标进入相机镜头，将camera和view绑定，找到一个合使的观察位置，分割两个视角(在边缘处点击右键选择verticalsplit)，一个用于摄像机，一个用于建模，如下图<br /><img src="/img/blenderpic/blender2-2.png" alt="模型2" /></p><p>在主体模型上挖两个坑，都是用内插面i＋挤压e实现，再给上面的坑加上货架cube实现,添加modifier，array，下图是我的设置<br /><img src="/img/blenderpic/blender2-3.png" alt="模型3" /></p><p>以下图为例创建三个panel，采用ctrl+F2可以给创建好的快速重命名，建好后都加入集合，可以适当将machine的顶部放大，最后按a全选右键选择shadeauto smooth <img src="/img/blenderpic/blender2-4.png" alt="模型4" /></p><p>接着在machine上建按钮，采用两个modifier实现按钮的排列,完成后做出不同类型的瓶子。放入machine中</p><h1 id="material">material</h1><p>将左下角的mode改为ShaderEditor,添加sun，调整角度，选中machine在mode里新建material</p><p>在采用 line art时出现问题，暂未解决，问题如下: <imgsrc="/img/blenderpic/blender2-5.png" alt="模型5" />模型有部分未被线条包围有些不该出现线条的地方产生了线条。。</p><p>此文暂存！</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blender学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blender学习记录之Smooth 3D living room</title>
    <link href="/2024/07/25/blender1/"/>
    <url>/2024/07/25/blender1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下学习blender的学习过程,这个模型是按照油管上的一个博主的内容做的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Blender 3D Beginner Tutorial: Smooth 3D Living Room](https://youtu.be/dEGJeVnWZAA?si=eq0xsQRhnSmW-qhl)">[1]</span></a></sup>，</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://youtu.be/dEGJeVnWZAA?si=eq0xsQRhnSmW-qhl">Blender3D Beginner Tutorial: Smooth 3D Living Room</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blender学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
